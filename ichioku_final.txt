//@version=6
indicator(title="Custom Ichimoku Tradable Zone", shorttitle="Ichimoku TZ", overlay=true)

// ─────────────────────────────
// Ichimoku Inputs (Original)
// ─────────────────────────────
conversionPeriods   = input.int(9,  minval=1, title="Conversion Line Length")
basePeriods         = input.int(26, minval=1, title="Base Line Length")
laggingSpan2Periods = input.int(52, minval=1, title="Leading Span B Length")
displacement        = input.int(26, minval=1, title="Displacement")

// ─────────────────────────────
// Display Options
// ─────────────────────────────
showConversionLine = input.bool(false, title="Show Conversion Line", group="Display Options")
showBaseLine       = input.bool(false, title="Show Base Line", group="Display Options")
showLaggingSpan    = input.bool(false, title="Show Lagging Span", group="Display Options")

// ─────────────────────────────
// Custom Scan Inputs
// ─────────────────────────────
scanRange            = input.int(29, minval=1, title="Lookback Candles", tooltip="Number of candles to analyze.\nRecommended:\n• Short-term (1-5min): 15-29\n• Medium-term (15min-1H): 26-52\n• Long-term (4H-Daily): 52-100\nLower values = more frequent signals\nHigher values = more stable signals")
maxSpanBDeviationPct = input.float(0.55, title="Span B Range Threshold (%)", tooltip="Check the 'Thresholds' table (top-right) for dynamic recommendations based on your current chart data.\n\nGeneral ranges:\n• Stocks/Indices: 0.3-1.0%\n• Forex: 0.5-2.0%\n• Crypto: 0.5-3.0%\n• Very strict: 0.05-0.3%\n• Liberal: 1.0-5.0%")
maxSpanABGapPct      = input.float(0.80, title="Span A Proximity Threshold (%)", tooltip="Check the 'Thresholds' table (top-right) for dynamic recommendations based on your current chart data.\n\nGeneral ranges:\n• Stocks/Indices: 0.5-1.5%\n• Forex: 0.8-2.5%\n• Crypto: 0.8-3.5%\n• Very strict: 0.08-0.5%\n• Liberal: 1.5-5.0%")

lineColor = input.color(color.red, title="Marker Color")
showPercentages = input.bool(false, title="Show Percentage Values in Labels", group="Marker Options")
showTransparencyLines = input.bool(true, title="Show Transparency Lines (Visual Verification)", group="Marker Options", tooltip="Yellow line: Span B range (max to min)\nCyan line: Span A-B gap at max location")
useIchimokuOffset = input.bool(true, title="Use Ichimoku Displacement for Transparency Lines", group="Marker Options", tooltip="If enabled, uses the same offset as Ichimoku cloud. If disabled, uses custom offset below.")
transparencyLineOffset = input.int(26, minval=0, title="Transparency Lines Offset", group="Marker Options", tooltip="Offset for transparency lines. Only used if 'Use Ichimoku Displacement' is disabled.")

// ─────────────────────────────
// Ichimoku Calculations
// ─────────────────────────────
donchian(len) =>
    math.avg(ta.lowest(len), ta.highest(len))

conversionLine = donchian(conversionPeriods)
baseLine       = donchian(basePeriods)
leadLine1      = math.avg(conversionLine, baseLine)   // Span A
leadLine2      = donchian(laggingSpan2Periods)         // Span B

// ─────────────────────────────
// Plot Original Ichimoku
// ─────────────────────────────
plot(conversionLine, color=#2962FF, title="Conversion Line", display=showConversionLine ? display.all : display.none)
plot(baseLine, color=#B71C1C, title="Base Line", display=showBaseLine ? display.all : display.none)
plot(close, offset = -displacement + 1, color=#43A047, title="Lagging Span", display=showLaggingSpan ? display.all : display.none)

p1 = plot(leadLine1, offset = displacement - 1, color=#A5D6A7, title="Leading Span A")
p2 = plot(leadLine2, offset = displacement - 1, color=#EF9A9A, title="Leading Span B")

plot(leadLine1 > leadLine2 ? leadLine1 : leadLine2,
     offset = displacement - 1,
     display = display.none)

plot(leadLine1 < leadLine2 ? leadLine1 : leadLine2,
     offset = displacement - 1,
     display = display.none)

fill(
    p1,
    p2,
    color = leadLine1 > leadLine2
        ? color.rgb(67, 160, 71, 90)
        : color.rgb(244, 67, 54, 90)
)

// ─────────────────────────────
// Check if Ichimoku values are valid (needed for both conditions)
// Span B needs at least laggingSpan2Periods bars to be calculated
// For forex, be more lenient - check current bar OR lookback window
// ─────────────────────────────
// Check current bar first
ichimokuValid = not na(leadLine2) and not na(leadLine1)

// If current bar invalid but we have enough bars, check lookback window
// This handles cases where current bar might be NA but historical data is valid
if not ichimokuValid and bar_index >= scanRange - 1
    // Check if we have any valid data in lookback window
    for i = 0 to math.min(scanRange - 1, 9)  // Check up to 10 bars
        if not na(leadLine1[i]) and not na(leadLine2[i])
            ichimokuValid := true
            break

// ─────────────────────────────
// CONDITION 1: Span B Range Condition
// (max(Span B) - min(Span B)) / average(Span B) ≤ threshold
// ─────────────────────────────
// CRITICAL: Only evaluate when we have enough bars
// Initialize with safe defaults
cond_spanB = false
spanB_range_pct = 999.0

// Call ta functions on every bar for consistency (Pine Script recommendation)
// But only use the results when we have enough bars
spanB_high = ta.highest(leadLine2, scanRange)
spanB_low  = ta.lowest(leadLine2, scanRange)
spanB_avg  = ta.sma(leadLine2, scanRange)

// CRITICAL FIX: Only evaluate condition when we have enough bars
// This prevents false positives when insufficient data is available
// For forex, be more lenient - evaluate whenever we have enough bars, even if some values are edge cases
if bar_index >= scanRange - 1
    // Check Ichimoku validity - if invalid, condition fails
    if ichimokuValid
        // Calculate Span B range percentage with safety check for division by zero
        // Use epsilon check instead of exact zero (better for forex)
        // Only set cond_spanB to true if calculation is valid
        if not na(spanB_high) and not na(spanB_low) and not na(spanB_avg) and math.abs(spanB_avg) > 0.000001
            spanB_range_pct := (spanB_high - spanB_low) / spanB_avg * 100
            cond_spanB := spanB_range_pct <= maxSpanBDeviationPct
        else
            // If ta functions returned NA or invalid values, condition fails
            cond_spanB := false
    else
        // Ichimoku values invalid - condition fails
        cond_spanB := false
else
    // Not enough bars - explicitly set to false
    cond_spanB := false

// Find bar indices where max and min Span B occurred (for transparency line)
// Initialize with default values
int spanB_high_bar = 0
int spanB_low_bar = 0
float spanB_high_actual = leadLine2
float spanB_low_actual = leadLine2

// Only find bars if we have enough data and valid spanB values
if bar_index >= scanRange - 1 and ichimokuValid and not na(spanB_high) and not na(spanB_low)
    // Use percentage-based tolerance for floating point comparison
    spanB_high_bar := -1
    spanB_low_bar := -1
    spanB_high_actual := na
    spanB_low_actual := na
    float tolerance_pct = 0.01  // 0.01% tolerance
    
    for i = 0 to scanRange - 1
        // Find first occurrence of max Span B (with percentage tolerance)
        if spanB_high_bar == -1
            diff_pct = math.abs(leadLine2[i] - spanB_high) / spanB_high * 100
            if diff_pct < tolerance_pct
                spanB_high_bar := i
                spanB_high_actual := leadLine2[i]  // Use actual value at this bar
        // Find first occurrence of min Span B (with percentage tolerance)
        if spanB_low_bar == -1
            diff_pct = math.abs(leadLine2[i] - spanB_low) / spanB_low * 100
            if diff_pct < tolerance_pct
                spanB_low_bar := i
                spanB_low_actual := leadLine2[i]  // Use actual value at this bar
        // Break early if both found
        if spanB_high_bar >= 0 and spanB_low_bar >= 0
            break
    
    // Fallback: if not found, search for closest values
    if spanB_high_bar == -1
        float min_diff = 999999.0
        for i = 0 to scanRange - 1
            diff = math.abs(leadLine2[i] - spanB_high)
            if diff < min_diff
                min_diff := diff
                spanB_high_bar := i
                spanB_high_actual := leadLine2[i]  // Use actual value at this bar
    
    if spanB_low_bar == -1
        float min_diff = 999999.0
        for i = 0 to scanRange - 1
            diff = math.abs(leadLine2[i] - spanB_low)
            if diff < min_diff
                min_diff := diff
                spanB_low_bar := i
                spanB_low_actual := leadLine2[i]  // Use actual value at this bar
    
    // Final fallback: use the ta.highest/lowest values if actual values not found
    if na(spanB_high_actual)
        spanB_high_actual := spanB_high
    if na(spanB_low_actual)
        spanB_low_actual := spanB_low
    
    // Ensure bars are always found (final safety check)
    if spanB_high_bar == -1
        spanB_high_bar := 0
        spanB_high_actual := leadLine2[0]
    if spanB_low_bar == -1
        spanB_low_bar := 0
        spanB_low_actual := leadLine2[0]

// ─────────────────────────────
// CONDITION 2: Span A Proximity Condition
// ALL candles must satisfy: abs(Span A - Span B) / Span B ≤ threshold
// ─────────────────────────────
// Check ALL candles in the lookback window
allCandlesValid = false
max_gap_pct = 0.0
int max_gap_bar = 0
float max_gap_spanA_value = na
float max_gap_spanB_value = na

// Only check if we have enough bars
// Evaluate condition whenever we have enough bars - be more lenient for forex
if bar_index >= scanRange - 1
    // Check if we have at least some valid Ichimoku data to work with
    if ichimokuValid
        allCandlesValid := true
    else
        // Ichimoku values invalid - condition fails
        allCandlesValid := false
    
    // Initialize with first bar values to ensure we always have valid starting point
    // Use a small epsilon check instead of exact zero check (better for forex)
    if not na(leadLine1[0]) and not na(leadLine2[0]) and math.abs(leadLine2[0]) > 0.000001
        max_gap_bar := 0
        max_gap_spanA_value := leadLine1[0]
        max_gap_spanB_value := leadLine2[0]
    
    // Check ALL candles - if any candle is NA or fails condition, allCandlesValid becomes false
    for i = 0 to scanRange - 1
        // Use epsilon check instead of exact zero (better for forex with small values)
        if not na(leadLine1[i]) and not na(leadLine2[i]) and math.abs(leadLine2[i]) > 0.000001
            gap_pct = math.abs(leadLine1[i] - leadLine2[i]) / leadLine2[i] * 100
            if gap_pct > max_gap_pct
                max_gap_pct := gap_pct
                max_gap_bar := i
                max_gap_spanA_value := leadLine1[i]
                max_gap_spanB_value := leadLine2[i]
            if gap_pct > maxSpanABGapPct
                allCandlesValid := false
        else
            // If any candle has NA values or near-zero, condition fails (ALL candles must be valid)
            allCandlesValid := false
    
    // Ensure max_gap values are always valid (fallback to first bar if needed)
    // Only set fallbacks when we have enough bars
    if na(max_gap_spanA_value) or na(max_gap_spanB_value)
        max_gap_bar := 0
        max_gap_spanA_value := leadLine1[0]
        max_gap_spanB_value := leadLine2[0]
    // Final safety check: use current values if still NA
    if na(max_gap_spanA_value)
        max_gap_spanA_value := leadLine1
    if na(max_gap_spanB_value)
        max_gap_spanB_value := leadLine2
else
    // Not enough bars - explicitly ensure condition fails
    allCandlesValid := false
    // Set safe default values
    max_gap_bar := 0
    max_gap_spanA_value := leadLine1
    max_gap_spanB_value := leadLine2

cond_spanAB = allCandlesValid

// ─────────────────────────────
// Tradable Zone Logic
// ─────────────────────────────
// Both conditions are already boolean, combine them directly
tradableZone = cond_spanB and cond_spanAB

// Trigger ONLY when conditions turn true
// On first bar, tradableZone[1] defaults to false, so this works correctly
trigger = tradableZone and not tradableZone[1]

// Trigger when tradable zone ends (was true, now false)
endTrigger = not tradableZone and tradableZone[1]

// ─────────────────────────────
// Visual Marker: Line + ✅ Emoji (Zone Start)
// ─────────────────────────────
if trigger
    // Vertical line on trigger candle (at current bar, not offset)
    line.new(
        x1 = bar_index,
        y1 = low,
        x2 = bar_index,
        y2 = high,
        color = lineColor,
        width = 2,
        style = line.style_solid
    )
    
    // Transparency lines (showing condition measurements at offset positions)
    // These lines serve as visual cross-verification tools
    // NOTE: Calculation is based on candles, but plotting is done at offset positions
    // Plotted at offset positions of candles where conditions transition from false to true
    if showTransparencyLines
        // Ensure bar indices are within valid range
        spanB_high_bar_valid = math.max(0, math.min(spanB_high_bar, scanRange - 1))
        spanB_low_bar_valid = math.max(0, math.min(spanB_low_bar, scanRange - 1))
        max_gap_bar_valid = math.max(0, math.min(max_gap_bar, scanRange - 1))
        
        // Calculate offset positions where Span values are plotted
        // Use customizable offset (either Ichimoku displacement or custom value)
        transparencyOffset = useIchimokuOffset ? (displacement - 1) : (transparencyLineOffset - 1)
        // Offset positions = (bar_index - bars_ago) + offset
        // Calculate base positions (where the historical bars are plotted at offset)
        x1_spanB_high_base = bar_index - spanB_high_bar_valid  // Base position of max Span B bar
        x2_spanB_low_base = bar_index - spanB_low_bar_valid    // Base position of min Span B bar
        x_max_gap_base = bar_index - max_gap_bar_valid          // Base position of max gap bar
        
        // Apply offset to get the actual plot positions
        x1_spanB_high = x1_spanB_high_base + transparencyOffset  // Offset plot of max Span B
        x2_spanB_low = x2_spanB_low_base + transparencyOffset    // Offset plot of min Span B
        x_max_gap = x_max_gap_base + transparencyOffset          // Offset plot of max gap candle
        
        // Ensure coordinates are valid (not negative and reasonable)
        // Pine Script has limits on how far back you can reference bars
        // Limit coordinates to be within reasonable range from current bar (max 5000 bars back)
        maxBarDistance = 5000
        minBarIndex = math.max(0, bar_index - maxBarDistance)
        x1_spanB_high := math.max(minBarIndex, math.min(x1_spanB_high, bar_index + 100))
        x2_spanB_low := math.max(minBarIndex, math.min(x2_spanB_low, bar_index + 100))
        x_max_gap := math.max(minBarIndex, math.min(x_max_gap, bar_index + 100))
        
        // Get Span B values at the identified bars (these are the actual plotted values)
        // Since zone detection is working, these values MUST exist and be valid
        // Use the actual found values first, then fallback to ensure we always have valid values
        y1_spanB_high = not na(spanB_high_actual) ? spanB_high_actual : (not na(leadLine2[spanB_high_bar_valid]) ? leadLine2[spanB_high_bar_valid] : spanB_high)
        y2_spanB_low = not na(spanB_low_actual) ? spanB_low_actual : (not na(leadLine2[spanB_low_bar_valid]) ? leadLine2[spanB_low_bar_valid] : spanB_low)
        
        // Final safety: if still NA (should never happen if zone detection works), use current value
        if na(y1_spanB_high)
            y1_spanB_high := leadLine2
        if na(y2_spanB_low)
            y2_spanB_low := leadLine2
        
        // Line 1: Span B Extremes Connector
        // Connects the offset plot of maximum Span B to the offset plot of minimum Span B
        // This line visually represents the full effective range of Span B across the offset window
        // CRITICAL: This line MUST be drawn if zone detection is working
        // Always draw - ensures transparency lines are visible for all triggers
        // CRITICAL: Since trigger is true, cond_spanB is true, so spanB_high and spanB_low are guaranteed valid
        // Use them directly to ensure line always draws
        final_y1 = not na(y1_spanB_high) ? y1_spanB_high : spanB_high
        final_y2 = not na(y2_spanB_low) ? y2_spanB_low : spanB_low
        
        // Absolute fallback: if somehow still invalid, use spanB_high/spanB_low directly (they're valid if cond_spanB is true)
        if na(final_y1) or final_y1 == 0.0
            final_y1 := spanB_high
        if na(final_y2) or final_y2 == 0.0
            final_y2 := spanB_low
        
        // Line 1: Span B Extremes Connector - ALWAYS DRAW when trigger fires
        // Ensure coordinates are valid and line will be visible
        if not na(x1_spanB_high) and not na(x2_spanB_low) and not na(final_y1) and not na(final_y2)
            line.new(
                x1 = x1_spanB_high,
                y1 = final_y1,  // Span B value at max bar (plotted at offset position)
                x2 = x2_spanB_low,
                y2 = final_y2,    // Span B value at min bar (plotted at offset position)
                color = color.new(color.yellow, 0),
                width = 3,
                style = line.style_solid,
                extend = extend.none
            )
        
        // Ensure max_gap values are valid (multiple fallback layers)
        gap_spanA = na(max_gap_spanA_value) ? (na(leadLine1[max_gap_bar_valid]) ? leadLine1 : leadLine1[max_gap_bar_valid]) : max_gap_spanA_value
        gap_spanB = na(max_gap_spanB_value) ? (na(leadLine2[max_gap_bar_valid]) ? leadLine2 : leadLine2[max_gap_bar_valid]) : max_gap_spanB_value
        
        // Final fallback: use current values if still NA
        if na(gap_spanA)
            gap_spanA := leadLine1
        if na(gap_spanB)
            gap_spanB := leadLine2
        
        // Line 2: Span A–Span B Deviation Connector
        // Connects both offset plot points of the candle where abs(Span A - Span B) is maximum
        // This line highlights the point of maximum divergence between Span A and Span B
        // within the same offset context
        // Always draw - ensures transparency lines are visible for all triggers
        line.new(
            x1 = x_max_gap,                    // Same offset position (max gap candle)
            y1 = gap_spanA,                    // Span A offset plot point at max gap candle
            x2 = x_max_gap,                    // Same offset position (max gap candle)
            y2 = gap_spanB,                     // Span B offset plot point at max gap candle
            color = color.new(#00FFFF, 0),     // Cyan color using RGB
            width = 3,
            style = line.style_solid,
            extend = extend.none
        )
    
    // ✅ marker - at current Span A offset plot point
    labelText = showPercentages ? "✅\nSpanB: " + str.tostring(spanB_range_pct, "#.##") + "%\nGap: " + str.tostring(max_gap_pct, "#.##") + "%" : "✅"
    label.new(
        x = bar_index + displacement - 1,
        y = leadLine1,
        text = labelText,
        textcolor = lineColor,
        style = label.style_label_center,
        size = size.huge
    )

// ─────────────────────────────
// Visual Marker: Line + ❌ Emoji (Zone End)
// ─────────────────────────────
if endTrigger
    // Vertical line on trigger candle (at current bar, not offset)
    line.new(
        x1 = bar_index,
        y1 = low,
        x2 = bar_index,
        y2 = high,
        color = lineColor,
        width = 2,
        style = line.style_solid
    )
    
    // Transparency lines (showing condition measurements at offset positions)
    // These lines serve as visual cross-verification tools
    // NOTE: Calculation is based on candles, but plotting is done at offset positions
    // Plotted at offset positions of candles where conditions transition from true to false
    if showTransparencyLines
        // Ensure bar indices are within valid range
        spanB_high_bar_valid = math.max(0, math.min(spanB_high_bar, scanRange - 1))
        spanB_low_bar_valid = math.max(0, math.min(spanB_low_bar, scanRange - 1))
        max_gap_bar_valid = math.max(0, math.min(max_gap_bar, scanRange - 1))
        
        // Calculate offset positions where Span values are plotted
        // Use customizable offset (either Ichimoku displacement or custom value)
        transparencyOffset = useIchimokuOffset ? (displacement - 1) : (transparencyLineOffset - 1)
        // Offset positions = (bar_index - bars_ago) + offset
        // Calculate base positions (where the historical bars are plotted at offset)
        x1_spanB_high_base = bar_index - spanB_high_bar_valid  // Base position of max Span B bar
        x2_spanB_low_base = bar_index - spanB_low_bar_valid    // Base position of min Span B bar
        x_max_gap_base = bar_index - max_gap_bar_valid          // Base position of max gap bar
        
        // Apply offset to get the actual plot positions
        x1_spanB_high = x1_spanB_high_base + transparencyOffset  // Offset plot of max Span B
        x2_spanB_low = x2_spanB_low_base + transparencyOffset    // Offset plot of min Span B
        x_max_gap = x_max_gap_base + transparencyOffset          // Offset plot of max gap candle
        
        // Ensure coordinates are valid (not negative and reasonable)
        // Pine Script has limits on how far back you can reference bars
        // Limit coordinates to be within reasonable range from current bar (max 5000 bars back)
        maxBarDistance = 5000
        minBarIndex = math.max(0, bar_index - maxBarDistance)
        x1_spanB_high := math.max(minBarIndex, math.min(x1_spanB_high, bar_index + 100))
        x2_spanB_low := math.max(minBarIndex, math.min(x2_spanB_low, bar_index + 100))
        x_max_gap := math.max(minBarIndex, math.min(x_max_gap, bar_index + 100))
        
        // Get Span B values at the identified bars (these are the actual plotted values)
        // Since zone detection is working, these values MUST exist and be valid
        // Use the actual found values first, then fallback to ensure we always have valid values
        y1_spanB_high = not na(spanB_high_actual) ? spanB_high_actual : (not na(leadLine2[spanB_high_bar_valid]) ? leadLine2[spanB_high_bar_valid] : spanB_high)
        y2_spanB_low = not na(spanB_low_actual) ? spanB_low_actual : (not na(leadLine2[spanB_low_bar_valid]) ? leadLine2[spanB_low_bar_valid] : spanB_low)
        
        // Final safety: if still NA (should never happen if zone detection works), use current value
        if na(y1_spanB_high)
            y1_spanB_high := leadLine2
        if na(y2_spanB_low)
            y2_spanB_low := leadLine2
        
        // Line 1: Span B Extremes Connector
        // Connects the offset plot of maximum Span B to the offset plot of minimum Span B
        // This line visually represents the full effective range of Span B across the offset window
        // CRITICAL: This line MUST be drawn if zone detection is working
        // Always draw - ensures transparency lines are visible for all triggers
        // CRITICAL: Since trigger is true, cond_spanB is true, so spanB_high and spanB_low are guaranteed valid
        // Use them directly to ensure line always draws
        final_y1 = not na(y1_spanB_high) ? y1_spanB_high : spanB_high
        final_y2 = not na(y2_spanB_low) ? y2_spanB_low : spanB_low
        
        // Absolute fallback: if somehow still invalid, use spanB_high/spanB_low directly (they're valid if cond_spanB is true)
        if na(final_y1) or final_y1 == 0.0
            final_y1 := spanB_high
        if na(final_y2) or final_y2 == 0.0
            final_y2 := spanB_low
        
        // Line 1: Span B Extremes Connector - ALWAYS DRAW when trigger fires
        // Ensure coordinates are valid and line will be visible
        if not na(x1_spanB_high) and not na(x2_spanB_low) and not na(final_y1) and not na(final_y2)
            line.new(
                x1 = x1_spanB_high,
                y1 = final_y1,  // Span B value at max bar (plotted at offset position)
                x2 = x2_spanB_low,
                y2 = final_y2,    // Span B value at min bar (plotted at offset position)
                color = color.new(color.yellow, 0),
                width = 3,
                style = line.style_solid,
                extend = extend.none
            )
        
        // Ensure max_gap values are valid (multiple fallback layers)
        gap_spanA = na(max_gap_spanA_value) ? (na(leadLine1[max_gap_bar_valid]) ? leadLine1 : leadLine1[max_gap_bar_valid]) : max_gap_spanA_value
        gap_spanB = na(max_gap_spanB_value) ? (na(leadLine2[max_gap_bar_valid]) ? leadLine2 : leadLine2[max_gap_bar_valid]) : max_gap_spanB_value
        
        // Final fallback: use current values if still NA
        if na(gap_spanA)
            gap_spanA := leadLine1
        if na(gap_spanB)
            gap_spanB := leadLine2
        
        // Line 2: Span A–Span B Deviation Connector
        // Connects both offset plot points of the candle where abs(Span A - Span B) is maximum
        // This line highlights the point of maximum divergence between Span A and Span B
        // within the same offset context
        // Always draw - ensures transparency lines are visible for all triggers
        line.new(
            x1 = x_max_gap,                    // Same offset position (max gap candle)
            y1 = gap_spanA,                    // Span A offset plot point at max gap candle
            x2 = x_max_gap,                    // Same offset position (max gap candle)
            y2 = gap_spanB,                     // Span B offset plot point at max gap candle
            color = color.new(#00FFFF, 0),     // Cyan color using RGB
            width = 3,
            style = line.style_solid,
            extend = extend.none
        )
    
    // ❌ marker - at current Span A offset plot point
    labelText = showPercentages ? "❌\nSpanB: " + str.tostring(spanB_range_pct, "#.##") + "%\nGap: " + str.tostring(max_gap_pct, "#.##") + "%" : "❌"
    label.new(
        x = bar_index + displacement - 1,
        y = leadLine1,
        text = labelText,
        textcolor = lineColor,
        style = label.style_label_center,
        size = size.huge
    )
